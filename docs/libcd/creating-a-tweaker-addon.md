# Creating a Tweaker addon

The primary draw of a tweaker system is extensibility. If mods can't add their own code for tweaking their behavior, what's the point? The advantage of LibCD tweakers on the Java side is that they're almost *entirely* static. If you just want to write a utility class for registering your own extensions of `Recipe<?>`, you don't need a single line of non-static code. If you don't want a hard-dependency on LibCD but want to register new tweaker types, use a `FabricLoader.getInstance().isModLoaded("libcd")` check that loads a new class to register tweaker types in, so you don't run into `NoClassDefFound` errors.

## Tweaker classes
The `Tweaker` interface contains two methods: one called before tweaker scripts are run and one called after tweaker scripts are run. `Tweaker.prepareReload()` is called to clean out any stored tweaks, so that they won't stay in effect if they're removed. `Tweaker.getApplyMessage()` is called to log to the console how many tweaks were applied through the tweaker.

All tweaker classes need to be registered through the static method `Tweaker.addTweaker()`. The registered class will be passed as an object to scripts using the String `callName` parameter, so that scripts can call tweaker methods without needing to explicitly import all the tweakers they need. See the built-in [RecipeTweaker](https://github.com/CottonMC/LibCD/blob/master/src/main/java/io/github/cottonmc/libcd/tweaker/RecipeTweaker.java) and [Cotton's CauldronTweaker](https://github.com/CottonMC/cotton/blob/master/src/main/java/io/github/cottonmc/cotton/tweaker/CauldronTweaker.java) classes for examples.

## Assistant classes
There are various classes, like the `TweakerUtils` class, that are helpful to be able to call from a script but shouldn't be registered as a full tweaker. If you want to add an assistant class, you can register it through the `Tweaker.addAssistant()` method. Pass an instance of the class and a name to call it by in scripts. This name must be unique; it cannot be shared by any other assistant class or by any tweaker.

## Adding support for your recipes
LibCD already contains and registers a tweaker class for adding recipes. Because of that, you don't need to register your own tweaker class if you just want to support adding recipes. All you need is a static void with at least two method calls: `RecipeTweaker.getRecipeId()` to generate a unique identifier for the recipe, and `RecipeTweaker.addRecipe()` to add the recipe to the recipe manager. See [Practical Witchcraft's recipe tweaker class](https://github.com/CottonMC/PracticalWitchcraft/blob/master/src/main/java/io/github/cottonmc/witchcraft/recipe/WitchcraftRecipeTweaker.java) for an example.

Recipe-adding methods should only have strings, collections (arrays, lists, maps, etc.), primitives, and `ItemStack`s as parameters, as scripts in production environments do not have full access to Mojang classes. `TweakerUtils` allows creation of `ItemStack` objects without needing any obfuscated names, as well as getting objects from registries for various methods. If you need access to any other obfuscated classes, write a method to get them from `Identifier`s passed as strings.

Since recipes use the wrapped, obfuscated `Ingredient` class for inputs, The tweaker system includes a `RecipeParser` class for converting strings to Ingredients, along with parsing the two common representations of shaped crafting recipes: CraftTweaker style and Vanilla JSON style. The primary method in the parser is `RecipeParser.processIngredient()`, which will take an input string and parse it into one of three ingredient forms: a raw item, a tag (for strings prefixed with a #), or a special stack (for strings including a ->).

## Stack getters
There are some items, like potions, that work off a separate system for available items. Because of that, specifying that a `minecraft:potion` item in a recipe means that someone can use *any* potion in it, not just a bottle of water. Because of that, the tweaker system adds a system for getting ingredients (or output stacks) of special stacks called `TweakerStackGetter`s. New getters are registered through the `TweakerStackGetter.registerGetter()`, passing an Identifier for the getter and a lambda taking in another Identifier for the entry to return. To call the getter, a user will use a string `[getter id]->[entry id]`. To see an example of this, check [LibCD's call of the method](https://github.com/CottonMC/LibCD/blob/master/src/main/java/io/github/cottonmc/libcd/LibCD.java#L32-L36) for registering a getter for potions. If a getter can't find an entry, it should return `ItemStack.EMPTY`.